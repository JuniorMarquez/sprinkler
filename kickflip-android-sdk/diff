diff --git a/sdk/build.gradle b/sdk/build.gradle
index 380de14..ddeb027 100644
--- a/sdk/build.gradle
+++ b/sdk/build.gradle
@@ -13,7 +13,7 @@ android {
     buildToolsVersion "20.0"
 
     defaultConfig {
-        minSdkVersion 18
+        minSdkVersion 14
         targetSdkVersion 21
         versionCode getVersionCode()
         versionName getVersionName()
@@ -41,7 +41,7 @@ configurations {
 
 dependencies {
     compile 'com.google.guava:guava:16.0'
-    compile 'com.android.support:support-v4:19.+'
+    compile 'com.android.support:support-v4:21.+'
     // aws-sdk-android
     compile files('libs/aws-android-sdk-1.7.0-core.jar')
     compile files('libs/aws-android-sdk-1.7.0-s3.jar')
diff --git a/sdk/src/main/java/io/kickflip/sdk/Kickflip.java b/sdk/src/main/java/io/kickflip/sdk/Kickflip.java
index 191b579..155ac9b 100644
--- a/sdk/src/main/java/io/kickflip/sdk/Kickflip.java
+++ b/sdk/src/main/java/io/kickflip/sdk/Kickflip.java
@@ -18,7 +18,6 @@ import java.io.IOException;
 import io.kickflip.sdk.activity.BroadcastActivity;
 import io.kickflip.sdk.activity.GlassBroadcastActivity;
 import io.kickflip.sdk.activity.MediaPlayerActivity;
-import io.kickflip.sdk.api.KickflipApiClient;
 import io.kickflip.sdk.api.KickflipCallback;
 import io.kickflip.sdk.api.json.Stream;
 import io.kickflip.sdk.av.BroadcastListener;
@@ -34,13 +33,13 @@ import static com.google.common.base.Preconditions.checkNotNull;
  * <p/>
  * <h2>Setup</h2>
  * Before use Kickflip must be setup with your Kickflip Client ID and Client Secret with
- * {@link #setup(android.content.Context, String, String)}. These tokens are available in your kickflip
+ * {@link #setup(android.content.Context)}. These tokens are available in your kickflip
  * account dashboard.
  * <h2>Example Usage</h2>
  * <b>Starting a single live broadcast</b>
  * <p/>
  * <ol>
- * <li>{@link #setup(android.content.Context, String, String)}</li>
+ * <li>{@link #setup(android.content.Context)}</li>
  * <li>(Optional) {@link #setSessionConfig(io.kickflip.sdk.av.SessionConfig)}</li>
  * <li>{@link #startBroadcastActivity(android.app.Activity, io.kickflip.sdk.av.BroadcastListener)}</li>
  * </ol>
@@ -78,55 +77,28 @@ import static com.google.common.base.Preconditions.checkNotNull;
 public class Kickflip {
     public static final String TAG = "Kickflip";
     private static Context sContext;
-    private static String sClientKey;
-    private static String sClientSecret;
-
-    private static KickflipApiClient sKickflip;
 
     // Per-Stream settings
     private static SessionConfig sSessionConfig;          // Absolute path to root storage location
     private static BroadcastListener sBroadcastListener;
 
-    /**
-     * Register with Kickflip, creating a new user identity per app installation.
-     *
-     * @param context the host application's {@link android.content.Context}
-     * @param key     your Kickflip Client Key
-     * @param secret  your Kickflip Client Secret
-     * @return a {@link io.kickflip.sdk.api.KickflipApiClient} used to perform actions on behalf of a
-     * {@link io.kickflip.sdk.api.json.User}.
-     */
-    public static KickflipApiClient setup(Context context, String key, String secret) {
-        return setup(context, key, secret, null);
-    }
 
     /**
      * Register with Kickflip, creating a new user identity per app installation.
      *
      * @param context the host application's {@link android.content.Context}
-     * @param key     your Kickflip Client Key
-     * @param secret  your Kickflip Client Secret
-     * @param cb      A callback to be invoked when Kickflip user credentials are available.
-     * @return a {@link io.kickflip.sdk.api.KickflipApiClient} used to perform actions on behalf of
      * a {@link io.kickflip.sdk.api.json.User}.
      */
-    public static KickflipApiClient setup(Context context, String key, String secret, KickflipCallback cb) {
+    public static void setup(Context context) {
         sContext = context;
-        setApiCredentials(key, secret);
-        return getApiClient(context, cb);
-    }
-
-    private static void setApiCredentials(String key, String secret) {
-        sClientKey = key;
-        sClientSecret = secret;
     }
 
     /**
      * Start {@link io.kickflip.sdk.activity.BroadcastActivity}. This Activity
      * facilitates control over a single live broadcast.
      * <p/>
-     * <b>Must be called after {@link Kickflip#setup(android.content.Context, String, String)} or
-     * {@link Kickflip#setup(android.content.Context, String, String, io.kickflip.sdk.api.KickflipCallback)}.</b>
+     * <b>Must be called after {@link Kickflip#setup(android.content.Context)} or
+     * {@link Kickflip#setup(android.content.Context)}.</b>
      *
      * @param host     the host {@link android.app.Activity} initiating this action
      * @param listener an optional {@link io.kickflip.sdk.av.BroadcastListener} to be notified on
@@ -137,8 +109,6 @@ public class Kickflip {
         if (sSessionConfig == null) {
             setupDefaultSessionConfig();
         }
-        checkNotNull(sClientKey);
-        checkNotNull(sClientSecret);
         sBroadcastListener = listener;
         Intent broadcastIntent = new Intent(host, BroadcastActivity.class);
         broadcastIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
@@ -150,8 +120,6 @@ public class Kickflip {
         if (sSessionConfig == null) {
             setupDefaultSessionConfig();
         }
-        checkNotNull(sClientKey);
-        checkNotNull(sClientSecret);
         sBroadcastListener = listener;
         Log.i(TAG, "startGlassBA ready? " + readyToBroadcast());
         Intent broadcastIntent = new Intent(host, GlassBroadcastActivity.class);
@@ -163,8 +131,8 @@ public class Kickflip {
      * Start {@link io.kickflip.sdk.activity.MediaPlayerActivity}. This Activity
      * facilitates playing back a Kickflip broadcast.
      * <p/>
-     * <b>Must be called after {@link Kickflip#setup(android.content.Context, String, String)} or
-     * {@link Kickflip#setup(android.content.Context, String, String, io.kickflip.sdk.api.KickflipCallback)}.</b>
+     * <b>Must be called after {@link Kickflip#setup(android.content.Context)} or
+     * {@link Kickflip#setup(android.content.Context)}.</b>
      *
      * @param host      the host {@link android.app.Activity} initiating this action
      * @param streamUrl a path of format https://kickflip.io/<stream_id> or https://xxx.xxx/xxx.m3u8
@@ -230,24 +198,6 @@ public class Kickflip {
     }
 
     /**
-     * Get the provided Kickflip Client Key
-     *
-     * @return the provided Kickflip Client Key
-     */
-    public static String getApiKey() {
-        return sClientKey;
-    }
-
-    /**
-     * Get the provided Kickflip Client Secret
-     *
-     * @return the provided Kickflip Client Secret
-     */
-    public static String getApiSecret() {
-        return sClientSecret;
-    }
-
-    /**
      * Return the {@link io.kickflip.sdk.av.SessionConfig} responsible for configuring this broadcast.
      *
      * @return the {@link io.kickflip.sdk.av.SessionConfig} responsible for configuring this broadcast.
@@ -284,7 +234,7 @@ public class Kickflip {
      * @return true if credentials required for broadcast are provided. false otherwise
      */
     public static boolean readyToBroadcast() {
-        return sClientKey != null && sClientSecret != null && sSessionConfig != null;
+        return sSessionConfig != null;
     }
 
     /**
@@ -311,38 +261,6 @@ public class Kickflip {
         return uri.getLastPathSegment().toString();
     }
 
-    /**
-     * Create a new instance of the KickflipApiClient if one hasn't
-     * yet been created, or the provided API keys don't match
-     * the existing client.
-     *
-     * @param context the context of the host application
-     * @return
-     */
-    public static KickflipApiClient getApiClient(Context context) {
-        return getApiClient(context, null);
-    }
-
-    /**
-     * Create a new instance of the KickflipApiClient if one hasn't
-     * yet been created, or the provided API keys don't match
-     * the existing client.
-     *
-     * @param context  the context of the host application
-     * @param callback an optional callback to be notified with the Kickflip user
-     *                 corresponding to the provided API keys.
-     * @return
-     */
-    public static KickflipApiClient getApiClient(Context context, KickflipCallback callback) {
-        checkNotNull(sClientKey);
-        checkNotNull(sClientSecret);
-        if (sKickflip == null || !sKickflip.getConfig().getClientId().equals(sClientKey)) {
-            sKickflip = new KickflipApiClient(context, sClientKey, sClientSecret, callback);
-        } else if (callback != null) {
-            callback.onSuccess(sKickflip.getActiveUser());
-        }
-        return sKickflip;
-    }
 
     private static void setupDefaultSessionConfig() {
         Log.i(TAG, "Setting default SessonConfig");
diff --git a/sdk/src/main/java/io/kickflip/sdk/api/KickflipApiClient.java b/sdk/src/main/java/io/kickflip/sdk/api/KickflipApiClient.java
deleted file mode 100644
index ee6e886..0000000
--- a/sdk/src/main/java/io/kickflip/sdk/api/KickflipApiClient.java
+++ /dev/null
@@ -1,871 +0,0 @@
-package io.kickflip.sdk.api;
-
-import android.content.Context;
-import android.content.SharedPreferences;
-import android.location.Location;
-import android.os.Handler;
-import android.util.Log;
-
-import com.amazonaws.auth.BasicAWSCredentials;
-import com.amazonaws.util.json.Jackson;
-import com.google.api.client.http.GenericUrl;
-import com.google.api.client.http.HttpContent;
-import com.google.api.client.http.HttpRequest;
-import com.google.api.client.http.HttpRequestFactory;
-import com.google.api.client.http.HttpResponse;
-import com.google.api.client.http.HttpResponseException;
-import com.google.api.client.http.UrlEncodedContent;
-import com.google.api.client.json.JsonFactory;
-import com.google.api.client.json.JsonObjectParser;
-import com.google.api.client.json.jackson2.JacksonFactory;
-import com.google.api.client.util.GenericData;
-
-import java.io.EOFException;
-import java.io.IOException;
-import java.math.BigInteger;
-import java.security.SecureRandom;
-import java.util.HashMap;
-import java.util.Map;
-
-import io.kickflip.sdk.R;
-import io.kickflip.sdk.api.json.HlsStream;
-import io.kickflip.sdk.api.json.Response;
-import io.kickflip.sdk.api.json.Stream;
-import io.kickflip.sdk.api.json.StreamList;
-import io.kickflip.sdk.api.json.User;
-import io.kickflip.sdk.exception.KickflipException;
-
-import static com.google.common.base.Preconditions.checkNotNull;
-
-/**
- * Kickflip API Client
- * <p/>
- * After construction, requests can be immediately performed.
- * The client will handle acquiring and refreshing OAuth
- * Access tokens as needed.
- * <p/>
- * The client is intended to manage a unique Kickflip user per Android device installation.
- */
-// TODO: Standardize Kickflip server error responses to have detail message
-public class KickflipApiClient extends OAuthClient {
-    private static final String TAG                 = "KickflipApiClient";
-    private static final boolean VERBOSE            = false;
-    private static final boolean DEV_ENDPOINT       = false;
-    private static final String NEW_USER            = "/user/new";
-    private static final String GET_USER_PUBLIC     = "/user/info";
-    private static final String GET_USER_PRIVATE    = "/user/uuid";
-    private static final String EDIT_USER           = "/user/change";
-    private static final String START_STREAM        = "/stream/start";
-    private static final String STOP_STREAM         = "/stream/stop";
-    private static final String SET_META            = "/stream/change";
-    private static final String GET_META            = "/stream/info";
-    private static final String FLAG_STREAM         = "/stream/flag";
-    private static final String SEARCH_KEYWORD      = "/search";
-    private static final String SEARCH_USER         = "/search/user";
-    private static final String SEARCH_GEO          = "/search/location";
-    private static final String API_VERSION         = "/1.1";
-    private static final int MAX_EOF_RETRIES        = 1;
-    private static int UNKNOWN_ERROR_CODE           = R.integer.generic_error;    // Error code used when none provided from server
-    private static String BASE_URL;
-    private JsonObjectParser mJsonObjectParser;             // Re-used across requests
-    private JsonFactory mJsonFactory;                       // Re-used across requests
-
-    private Handler mCallbackHandler;                       // Ensure callbacks are posted to consistent thread
-
-    /**
-     * Construct a KickflipApiClient. All callbacks from this client will occur
-     * on the current calling thread.
-     *
-     * @param appContext Your Application Context
-     * @param key        Your Kickflip Account Key
-     * @param secret     Your Kickflip Account Secret
-     */
-    public KickflipApiClient(Context appContext, String key, String secret) {
-        this(appContext, key, secret, null);
-    }
-
-    /**
-     * Construct a KickflipApiClient. All callbacks from this client will occur
-     * on the current calling thread.
-     *
-     * @param appContext Your Application Context
-     * @param key        Your Kickflip Account Key
-     * @param secret     Your Kickflip Account Secret
-     * @param cb         A callback to be notified when the provided Kickflip credentials are verified
-     */
-    public KickflipApiClient(Context appContext, String key, String secret, KickflipCallback cb) {
-        super(appContext, new OAuthConfig()
-                .setCredentialStoreName("KF")
-                .setClientId(key)
-                .setClientSecret(secret)
-                .setAccessTokenRequestUrl(BASE_URL + "/o/token/")
-                .setAccessTokenAuthorizeUrl(BASE_URL + "/o/authorize/"));
-        mCallbackHandler = new Handler();
-        initialize(cb);
-    }
-
-    private void initialize(KickflipCallback cb) {
-        if (getActiveUser() == null) {
-            createNewUser(cb);
-        } else {
-            postResponseToCallback(cb, getActiveUser());
-            if (VERBOSE)
-                Log.i(TAG, "Credentials stored " + getAWSCredentials());
-        }
-    }
-
-    /**
-     * Create a new Kickflip User.
-     * The User created as a result of this request is cached and managed by this KickflipApiClient
-     * throughout the life of the host Android application installation.
-     * <p/>
-     * The other methods of this client will be performed on behalf of the user created by this request,
-     * unless noted otherwise.
-     *
-     * @param username    The desired username for this Kickflip User. Will be altered if not unique for this Kickflip app.
-     * @param password    The password for this Kickflip user.
-     * @param email       The email address for this Kickflip user.
-     * @param displayName The display name for this Kickflip user.
-     * @param extraInfo   Map data to be associated with this Kickflip User.
-     * @param cb          This callback will receive a User in {@link io.kickflip.sdk.api.KickflipCallback#onSuccess(io.kickflip.sdk.api.json.Response)}
-     *                    or an Exception {@link io.kickflip.sdk.api.KickflipCallback#onError(io.kickflip.sdk.exception.KickflipException)}.
-     */
-    public void createNewUser(String username, String password, String email, String displayName, Map extraInfo, final KickflipCallback cb) {
-        GenericData data = new GenericData();
-        if (username != null) {
-            data.put("username", username);
-        }
-
-        final String finalPassword;
-        if (password != null) {
-            finalPassword = password;
-        } else {
-            finalPassword = generateRandomPassword();
-        }
-        data.put("password", finalPassword);
-
-        if (displayName != null) {
-            data.put("display_name", displayName);
-        }
-        if (email != null) {
-            data.put("email", email);
-        }
-        if (extraInfo != null) {
-            data.put("extra_info", Jackson.toJsonString(extraInfo));
-        }
-
-        post(NEW_USER, new UrlEncodedContent(data), User.class, new KickflipCallback() {
-            @Override
-            public void onSuccess(final Response response) {
-                if (VERBOSE)
-                    Log.i(TAG, "createNewUser response: " + response);
-                storeNewUserResponse((User) response, finalPassword);
-                postResponseToCallback(cb, response);
-            }
-
-            @Override
-            public void onError(final KickflipException error) {
-                Log.w(TAG, "createNewUser Error: " + error);
-                postExceptionToCallback(cb, error);
-            }
-        });
-    }
-
-    /**
-     * Create a new Kickflip User.
-     * The User created as a result of this request is active for this KickflipApiClient instance
-     * throughout the life of the host Android application installation, until a subsequent call to this method
-     * or {@link #loginUser(String, String, KickflipCallback)} }
-     * <p/>
-     * The other methods of this client will be performed on behalf of the user created by this request,
-     * unless noted otherwise.
-     *
-     * @param cb This callback will receive a User in {@link io.kickflip.sdk.api.KickflipCallback#onSuccess(io.kickflip.sdk.api.json.Response)}
-     *           or an Exception {@link io.kickflip.sdk.api.KickflipCallback#onError(io.kickflip.sdk.exception.KickflipException)}.
-     */
-    public void createNewUser(final KickflipCallback cb) {
-        final String password = generateRandomPassword();
-        post(NEW_USER, User.class, new KickflipCallback() {
-            @Override
-            public void onSuccess(final Response response) {
-                if (VERBOSE)
-                    Log.i(TAG, "createNewUser response: " + response);
-                storeNewUserResponse((User) response, password);
-                postResponseToCallback(cb, response);
-            }
-
-            @Override
-            public void onError(final KickflipException error) {
-                Log.w(TAG, "createNewUser Error: " + error);
-                postExceptionToCallback(cb, error);
-            }
-        });
-    }
-
-    /**
-     * Login an exiting Kickflip User and make it active.
-     *
-     * @param username The Kickflip user's username
-     * @param password The Kickflip user's password
-     * @param cb       This callback will receive a User in {@link io.kickflip.sdk.api.KickflipCallback#onSuccess(io.kickflip.sdk.api.json.Response)}
-     *                 or an Exception {@link io.kickflip.sdk.api.KickflipCallback#onError(io.kickflip.sdk.exception.KickflipException)}.
-     */
-    public void loginUser(String username, final String password, final KickflipCallback cb) {
-        GenericData data = new GenericData();
-        data.put("username", username);
-        data.put("password", password);
-
-        post(GET_USER_PRIVATE, new UrlEncodedContent(data), User.class, new KickflipCallback() {
-            @Override
-            public void onSuccess(final Response response) {
-                if (VERBOSE)
-                    Log.i(TAG, "loginUser response: " + response);
-                storeNewUserResponse((User) response, password);
-                postResponseToCallback(cb, response);
-            }
-
-            @Override
-            public void onError(final KickflipException error) {
-                Log.w(TAG, "loginUser Error: " + error);
-                postExceptionToCallback(cb, error);
-            }
-        });
-    }
-
-    /**
-     * Set the current active user's meta info. Pass a null argument to leave it as-is.
-     *
-     * @param newPassword the user's new password
-     * @param email       the user's new email address
-     * @param displayName The desired display name
-     * @param extraInfo   Arbitrary String data to associate with this user.
-     * @param cb          This callback will receive a User in {@link io.kickflip.sdk.api.KickflipCallback#onSuccess(io.kickflip.sdk.api.json.Response)}
-     *                    or an Exception {@link io.kickflip.sdk.api.KickflipCallback#onError(io.kickflip.sdk.exception.KickflipException)}.
-     */
-    public void setUserInfo(final String newPassword, String email, String displayName, Map extraInfo, final KickflipCallback cb) {
-        if (!assertActiveUserAvailable(cb)) return;
-        GenericData data = new GenericData();
-        final String finalPassword;
-        if (newPassword != null){
-            data.put("new_password", newPassword);
-            finalPassword = newPassword;
-        } else {
-            finalPassword = getPasswordForActiveUser();
-        }
-        if (email != null) data.put("email", email);
-        if (displayName != null) data.put("display_name", displayName);
-        if (extraInfo != null) data.put("extra_info", Jackson.toJsonString(extraInfo));
-
-        post(EDIT_USER, new UrlEncodedContent(data), User.class, new KickflipCallback() {
-            @Override
-            public void onSuccess(final Response response) {
-                if (VERBOSE)
-                    Log.i(TAG, "setUserInfo response: " + response);
-                storeNewUserResponse((User) response, finalPassword);
-                postResponseToCallback(cb, response);
-            }
-
-            @Override
-            public void onError(final KickflipException error) {
-                Log.w(TAG, "setUserInfo Error: " + error);
-                postExceptionToCallback(cb, error);
-            }
-        });
-    }
-
-    /**
-     * Get public user info
-     *
-     * @param username The Kickflip user's username
-     * @param cb       This callback will receive a User in {@link io.kickflip.sdk.api.KickflipCallback#onSuccess(io.kickflip.sdk.api.json.Response)}
-     *                 or an Exception {@link io.kickflip.sdk.api.KickflipCallback#onError(io.kickflip.sdk.exception.KickflipException)}.
-     */
-    public void getUserInfo(String username, final KickflipCallback cb) {
-        if (!assertActiveUserAvailable(cb)) return;
-        GenericData data = new GenericData();
-        data.put("username", username);
-
-        post(GET_USER_PUBLIC, new UrlEncodedContent(data), User.class, new KickflipCallback() {
-            @Override
-            public void onSuccess(final Response response) {
-                if (VERBOSE)
-                    Log.i(TAG, "getUserInfo response: " + response);
-                postResponseToCallback(cb, response);
-            }
-
-            @Override
-            public void onError(final KickflipException error) {
-                Log.w(TAG, "getUserInfo Error: " + error);
-                postExceptionToCallback(cb, error);
-            }
-        });
-    }
-
-
-    /**
-     * Start a new Stream. Must be called after
-     * {@link io.kickflip.sdk.api.KickflipApiClient#createNewUser(KickflipCallback)}
-     * Delivers stream endpoint destination data via a {@link io.kickflip.sdk.api.KickflipCallback}.
-     *
-     * @param cb This callback will receive a Stream subclass in {@link io.kickflip.sdk.api.KickflipCallback#onSuccess(io.kickflip.sdk.api.json.Response)}
-     *           depending on the Kickflip account type. Implementors should
-     *           check if the response is instanceof HlsStream, RtmpStream, etc.
-     */
-    public void startStream(Stream stream, final KickflipCallback cb) {
-        if (!assertActiveUserAvailable(cb)) return;
-        checkNotNull(stream);
-        startStreamWithUser(getActiveUser(), stream, cb);
-    }
-
-    /**
-     * Start a new Stream owned by the given User. Must be called after
-     * {@link io.kickflip.sdk.api.KickflipApiClient#createNewUser(KickflipCallback)}
-     * Delivers stream endpoint destination data via a {@link io.kickflip.sdk.api.KickflipCallback}.
-     *
-     * @param user The Kickflip User on whose behalf this request is performed.
-     * @param cb   This callback will receive a Stream subclass in {@link io.kickflip.sdk.api.KickflipCallback#onSuccess(io.kickflip.sdk.api.json.Response)}
-     *             depending on the Kickflip account type. Implementors should
-     *             check if the response is instanceof HlsStream, StartRtmpStreamResponse, etc.
-     */
-    private void startStreamWithUser(User user, Stream stream, final KickflipCallback cb) {
-        checkNotNull(user);
-        checkNotNull(stream);
-        // TODO: Be HLS / RTMP Agnostic
-        GenericData data = new GenericData();
-        data.put("uuid", user.getUUID());
-        data.put("private", stream.isPrivate());
-        if (stream.getTitle() != null) {
-            data.put("title", stream.getTitle());
-        }
-        if (stream.getDescription() != null) {
-            data.put("description", stream.getDescription());
-        }
-        if (stream.getExtraInfo() != null) {
-            data.put("extra_info", Jackson.toJsonString(stream.getExtraInfo()));
-        }
-        post(START_STREAM, new UrlEncodedContent(data), HlsStream.class, cb);
-    }
-
-    /**
-     * Stop a Stream. Must be called after
-     * {@link io.kickflip.sdk.api.KickflipApiClient#createNewUser(KickflipCallback)} and
-     * {@link io.kickflip.sdk.api.KickflipApiClient#startStream(io.kickflip.sdk.api.json.Stream, KickflipCallback)}
-     *
-     * @param cb This callback will receive a Stream subclass in {@link io.kickflip.sdk.api.KickflipCallback#onSuccess(io.kickflip.sdk.api.json.Response)}
-     *           depending on the Kickflip account type. Implementors should
-     *           check if the response is instanceof HlsStream, StartRtmpStreamResponse, etc.
-     */
-    public void stopStream(Stream stream, final KickflipCallback cb) {
-        if (!assertActiveUserAvailable(cb)) return;
-        stopStream(getActiveUser(), stream, cb);
-    }
-
-    /**
-     * Stop a Stream owned by the given Kickflip User.
-     *
-     * @param cb This callback will receive a Stream subclass in #onSuccess(response)
-     *           depending on the Kickflip account type. Implementors should
-     *           check if the response is instanceof HlsStream, StartRtmpStreamResponse, etc.
-     */
-    private void stopStream(User user, Stream stream, final KickflipCallback cb) {
-        checkNotNull(stream);
-        // TODO: Be HLS / RTMP Agnostic
-        // TODO: Add start / stop lat lon to Stream?
-        GenericData data = new GenericData();
-        data.put("stream_id", stream.getStreamId());
-        data.put("uuid", user.getUUID());
-        if (stream.getLatitude() != 0) {
-            data.put("lat", stream.getLatitude());
-        }
-        if (stream.getLongitude() != 0) {
-            data.put("lon", stream.getLongitude());
-        }
-        post(STOP_STREAM, new UrlEncodedContent(data), HlsStream.class, cb);
-    }
-
-    /**
-     * Send Stream Metadata for a {@link io.kickflip.sdk.api.json.Stream}.
-     * The target Stream must be owned by the User created with {@link io.kickflip.sdk.api.KickflipApiClient#createNewUser(KickflipCallback)}
-     * from this KickflipApiClient.
-     *
-     * @param stream the {@link io.kickflip.sdk.api.json.Stream} to get Meta data for
-     * @param cb     A callback to receive the updated Stream upon request completion
-     */
-    public void setStreamInfo(Stream stream, final KickflipCallback cb) {
-        if (!assertActiveUserAvailable(cb)) return;
-        GenericData data = new GenericData();
-        data.put("stream_id", stream.getStreamId());
-        data.put("uuid", getActiveUser().getUUID());
-        if (stream.getTitle() != null) {
-            data.put("title", stream.getTitle());
-        }
-        if (stream.getDescription() != null) {
-            data.put("description", stream.getDescription());
-        }
-        if (stream.getExtraInfo() != null) {
-            data.put("extra_info", Jackson.toJsonString(stream.getExtraInfo()));
-        }
-        if (stream.getLatitude() != 0) {
-            data.put("lat", stream.getLatitude());
-        }
-        if (stream.getLongitude() != 0) {
-            data.put("lon", stream.getLongitude());
-        }
-        if (stream.getCity() != null) {
-            data.put("city", stream.getCity());
-        }
-        if (stream.getState() != null) {
-            data.put("state", stream.getState());
-        }
-        if (stream.getCountry() != null) {
-            data.put("country", stream.getCountry());
-        }
-
-        if (stream.getThumbnailUrl() != null) {
-            data.put("thumbnail_url", stream.getThumbnailUrl());
-        }
-
-        data.put("private", stream.isPrivate());
-        data.put("deleted", stream.isDeleted());
-
-        post(SET_META, new UrlEncodedContent(data), Stream.class, cb);
-    }
-
-    /**
-     * Get Stream Metadata for a a public {@link io.kickflip.sdk.api.json.Stream}.
-     * The target Stream must belong a User of your Kickflip app.
-     *
-     * @param stream the {@link io.kickflip.sdk.api.json.Stream} to get Meta data for
-     * @param cb     A callback to receive the updated Stream upon request completion
-     */
-    public void getStreamInfo(Stream stream, final KickflipCallback cb) {
-        GenericData data = new GenericData();
-        data.put("stream_id", stream.getStreamId());
-
-        post(GET_META, new UrlEncodedContent(data), Stream.class, cb);
-    }
-
-    /**
-     * Get Stream Metadata for a a public {@link io.kickflip.sdk.api.json.Stream#mStreamId}.
-     * The target Stream must belong a User within your Kickflip app.
-     * <p/>
-     * This method is useful when digesting a Kickflip.io/<stream_id> url, where only
-     * the StreamId String is known.
-     *
-     * @param streamId the stream Id of the given stream. This is the value that appears
-     *                 in urls of form kickflip.io/<stream_id>
-     * @param cb       A callback to receive the current {@link io.kickflip.sdk.api.json.Stream} upon request completion
-     */
-    public void getStreamInfo(String streamId, final KickflipCallback cb) {
-        GenericData data = new GenericData();
-        data.put("stream_id", streamId);
-
-        post(GET_META, new UrlEncodedContent(data), Stream.class, cb);
-    }
-
-    /**
-     * Flag a {@link io.kickflip.sdk.api.json.Stream}. Used when the active Kickflip User does not own the Stream.
-     * <p/>
-     * To delete a recording the active Kickflip User owns, use
-     * {@link io.kickflip.sdk.api.KickflipApiClient#setStreamInfo(io.kickflip.sdk.api.json.Stream, KickflipCallback)}
-     *
-     * @param stream The Stream to flag.
-     * @param cb     A callback to receive the result of the flagging operation.
-     */
-    public void flagStream(Stream stream, final KickflipCallback cb) {
-        if (!assertActiveUserAvailable(cb)) return;
-        GenericData data = new GenericData();
-        data.put("uuid", getActiveUser().getUUID());
-        data.put("stream_id", stream.getStreamId());
-
-        post(FLAG_STREAM, new UrlEncodedContent(data), Stream.class, cb);
-    }
-
-    /**
-     * Get a List of {@link io.kickflip.sdk.api.json.Stream} objects created by the given Kickflip User.
-     *
-     * @param username the target Kickflip username
-     * @param cb       A callback to receive the resulting List of Streams
-     */
-    public void getStreamsByUsername(String username, int pageNumber, int itemsPerPage, final KickflipCallback cb) {
-        if (!assertActiveUserAvailable(cb)) return;
-        GenericData data = new GenericData();
-        addPaginationData(pageNumber, itemsPerPage, data);
-        data.put("uuid", getActiveUser().getUUID());
-        data.put("username", username);
-        post(SEARCH_USER, new UrlEncodedContent(data), StreamList.class, cb);
-    }
-
-    /**
-     * Get a List of {@link io.kickflip.sdk.api.json.Stream}s containing a keyword.
-     * <p/>
-     * This method searches all public recordings made by Users of your Kickflip app.
-     *
-     * @param keyword The String keyword to query
-     * @param cb      A callback to receive the resulting List of Streams
-     */
-    public void getStreamsByKeyword(String keyword, int pageNumber, int itemsPerPage, final KickflipCallback cb) {
-        if (!assertActiveUserAvailable(cb)) return;
-        GenericData data = new GenericData();
-        addPaginationData(pageNumber, itemsPerPage, data);
-        data.put("uuid", getActiveUser().getUUID());
-        if (keyword != null) {
-            data.put("keyword", keyword);
-        }
-        post(SEARCH_KEYWORD, new UrlEncodedContent(data), StreamList.class, cb);
-    }
-
-    /**
-     * Get a List of {@link io.kickflip.sdk.api.json.Stream}s near a geographic location.
-     * <p/>
-     * This method searches all public recordings made by Users of your Kickflip app.
-     *
-     * @param location The target Location
-     * @param radius   The target Radius in meters
-     * @param cb       A callback to receive the resulting List of Streams
-     */
-    public void getStreamsByLocation(Location location, int radius, int pageNumber, int itemsPerPage, final KickflipCallback cb) {
-        if (!assertActiveUserAvailable(cb)) return;
-        GenericData data = new GenericData();
-        data.put("uuid", getActiveUser().getUUID());
-        data.put("lat", location.getLatitude());
-        data.put("lon", location.getLongitude());
-        if (radius != 0) {
-            data.put("radius", radius);
-        }
-        post(SEARCH_GEO, new UrlEncodedContent(data), StreamList.class, cb);
-    }
-
-    /**
-     * Do a POST Request, creating a new user if necessary
-     *
-     * @param endpoint      Kickflip endpoint. e.g /user/new
-     * @param responseClass Class of the expected response
-     * @param cb            Callback that will receive an instance of responseClass
-     */
-    private void post(final String endpoint, final Class responseClass, final KickflipCallback cb) {
-        post(endpoint, null, responseClass, cb);
-    }
-
-    /**
-     * Do a POST Request, creating a new user if necessary
-     *
-     * @param endpoint      Kickflip endpoint. e.g /user/new
-     * @param body          POST body
-     * @param responseClass Class of the expected response
-     * @param cb            Callback that will receive an instance of responseClass
-     */
-    private void post(final String endpoint, final HttpContent body, final Class responseClass, final KickflipCallback cb) {
-        acquireAccessToken(new OAuthCallback() {
-            @Override
-            public void onSuccess(HttpRequestFactory requestFactory) {
-                request(requestFactory, METHOD.POST, makeApiUrl(endpoint), body, responseClass, cb);
-            }
-
-            @Override
-            public void onFailure(Exception e) {
-                postExceptionToCallback(cb, UNKNOWN_ERROR_CODE);
-            }
-        });
-    }
-
-    private void request(HttpRequestFactory requestFactory, final METHOD method, final String url, final HttpContent content, final Class responseClass, final KickflipCallback cb) {
-        if (VERBOSE)
-            Log.i(TAG, String.format("REQUEST: %S : %s body: %s", method, shortenUrlString(url), (content == null ? "" : Jackson.toJsonPrettyString(content))));
-        try {
-            HttpRequest request = null;
-            switch (method) {
-                case GET:
-                    request = requestFactory.buildGetRequest(
-                            new GenericUrl(url)).setParser(getJsonObjectParser());
-                    break;
-                case POST:
-                    request = requestFactory.buildPostRequest(
-                            new GenericUrl(url), content).setParser(getJsonObjectParser());
-                    break;
-            }
-            executeAndRetryRequest(request, responseClass, cb);
-        } catch (final IOException exception) {
-            // First try to handle as HttpResponseException
-            try {
-                HttpResponseException httpException = (HttpResponseException) exception;
-                // If this cast suceeds, the HTTP Status code must be >= 300
-                Log.i(TAG, "HttpException: " + httpException.getStatusCode());
-                switch (httpException.getStatusCode()) {
-                    case 403:
-                        // OAuth Access Token invalid
-                        Log.i(TAG, "Error 403: OAuth Token appears invalid. Clearing");
-                        clearAccessToken();
-                        acquireAccessToken(new OAuthCallback() {
-                            @Override
-                            public void onSuccess(HttpRequestFactory oauthRequestFactory) {
-                                request(oauthRequestFactory, method, url, content, responseClass, cb);
-                            }
-
-                            @Override
-                            public void onFailure(Exception e) {
-                                postExceptionToCallback(cb, UNKNOWN_ERROR_CODE);
-                            }
-                        });
-                        break;
-                    case 400:
-                        // Bad Client Credentials
-                        Log.e(TAG, "Error 400: Check your Client key and secret");
-                        break;
-                    default:
-                        Log.w(TAG, String.format("Unhandled Http Error %d : %s",
-                                httpException.getStatusCode(),
-                                httpException.getMessage()));
-                }
-                if (VERBOSE)
-                    Log.i(TAG, "RESPONSE: " + shortenUrlString(url) + " " + exception.getMessage());
-                postExceptionToCallback(cb, UNKNOWN_ERROR_CODE);
-            } catch (ClassCastException e) {
-                // A non-HTTP releated error occured.
-                Log.w(TAG, String.format("Unhandled Error: %s. Stack trace follows:", e.getMessage()));
-                exception.printStackTrace();
-                postExceptionToCallback(cb, UNKNOWN_ERROR_CODE);
-            }
-        }
-    }
-
-    /**
-     * Execute a HTTPRequest and retry up to {@link io.kickflip.sdk.api.KickflipApiClient#MAX_EOF_RETRIES} times if an EOFException occurs.
-     * This is an attempt to address what appears to be a bug in NetHttpTransport
-     * <p/>
-     * See <a href="https://code.google.com/p/google-api-java-client/issues/detail?id=869&can=4&colspec=Milestone%20Priority%20Component%20Type%20Summary%20ID%20Status%20Owner">This issue</a>
-     *
-     * @param request
-     * @param responseClass
-     * @param cb
-     * @throws IOException
-     */
-    private void executeAndRetryRequest(HttpRequest request, Class responseClass, KickflipCallback cb) throws IOException {
-        int numRetries = 0;
-        while (numRetries < MAX_EOF_RETRIES + 1) {
-            try {
-                executeAndHandleHttpRequest(request, responseClass, cb);
-                // If executeAndHandleHttpRequest completes without throwing EOFException
-                // we're good
-                return;
-            } catch (EOFException eof) {
-                if (VERBOSE) Log.i(TAG, "Got EOFException. Retrying..");
-                // An EOFException may be due to a bug in the way Connections are recycled
-                // within the NetHttpTransport package. Ignore and retry
-            }
-            numRetries++;
-        }
-        postExceptionToCallback(cb, UNKNOWN_ERROR_CODE);
-    }
-
-    private void executeAndHandleHttpRequest(HttpRequest request, Class responseClass, KickflipCallback cb) throws IOException {
-        handleHttpResponse(request.execute(), responseClass, cb);
-    }
-
-    /**
-     * Verify HTTP response was successful
-     * and pass to handleKickflipResponse.
-     * <p/>
-     * If we have an HttpResponse at all, it means
-     * the status code was < 300, so as far as http inspection
-     * goes, this method simply enforces status code of 200
-     *
-     * @param response
-     * @param responseClass
-     * @param cb            Must not be null
-     * @throws IOException
-     */
-    private void handleHttpResponse(HttpResponse response, Class<? extends Response> responseClass, KickflipCallback cb) throws IOException {
-        //Object parsedResponse = response.parseAs(responseClass);
-        if (isSuccessResponse(response)) {
-            // Http Success
-            handleKickflipResponse(response, responseClass, cb);
-            //cb.onSuccess(responseClass.cast(parsedResponse));
-        } else {
-            // Http Failure
-            if (VERBOSE)
-                Log.i(TAG, String.format("RESPONSE (F): %s body: %s", shortenUrlString(response.getRequest().getUrl().toString()), response.getContent().toString()));
-            postExceptionToCallback(cb, UNKNOWN_ERROR_CODE);
-        }
-    }
-
-    /**
-     * Parse the HttpResponse as the appropriate Response subclass
-     *
-     * @param response
-     * @param responseClass
-     * @param cb
-     * @throws IOException
-     */
-    private void handleKickflipResponse(HttpResponse response, Class<? extends Response> responseClass, KickflipCallback cb) throws IOException {
-        if (cb == null) return;
-        HashMap responseMap = null;
-        Response kickFlipResponse = response.parseAs(responseClass);
-        if (VERBOSE)
-            Log.i(TAG, String.format("RESPONSE: %s body: %s", shortenUrlString(response.getRequest().getUrl().toString()), Jackson.toJsonPrettyString(kickFlipResponse)));
-//        if (Stream.class.isAssignableFrom(responseClass)) {
-//            if( ((String) responseMap.get("stream_type")).compareTo("HLS") == 0){
-//                kickFlipResponse = response.parseAs(HlsStream.class);
-//            } else if( ((String) responseMap.get("stream_type")).compareTo("RTMP") == 0){
-//                // TODO:
-//            }
-//        } else if(User.class.isAssignableFrom(responseClass)){
-//            kickFlipResponse = response.parseAs(User.class);
-//        }
-        if (kickFlipResponse == null) {
-            postExceptionToCallback(cb, UNKNOWN_ERROR_CODE);
-        } else if (!kickFlipResponse.isSuccessful()) {
-            postExceptionToCallback(cb, UNKNOWN_ERROR_CODE);
-        } else {
-            postResponseToCallback(cb, kickFlipResponse);
-        }
-    }
-
-    private void storeNewUserResponse(User response, String password) {
-        getStorage().edit()
-                .putString("app_name", response.getApp())
-                .putString("name", response.getName())
-                .putString("password", password)
-                .putString("uuid", response.getUUID())
-                .putString("uuid", response.getUUID())
-                .apply();
-    }
-
-    private String getPasswordForActiveUser() {
-        return getStorage().getString("password", null);
-    }
-
-    private boolean isUserCached() {
-        //TODO: Ensure this use belongs to the current app
-        return getStorage().contains("uuid");
-    }
-
-    private BasicAWSCredentials getAWSCredentials() {
-        return new BasicAWSCredentials(
-                getStorage().getString("aws_access_key", ""),
-                getStorage().getString("aws_secret_key", ""));
-
-    }
-
-    /**
-     * Get the current active Kickflip User. If no User has been created, returns null.
-     * <p/>
-     * This will be the User created on the last call to
-     * {@link io.kickflip.sdk.api.KickflipApiClient#createNewUser(KickflipCallback)}
-     *
-     * @return
-     */
-    public User getActiveUser() {
-        SharedPreferences prefs = getStorage();
-        if (prefs.contains("uuid") && prefs.contains("name")) {
-            return new User(
-                    prefs.getString("app_name", ""),
-                    prefs.getString("name", ""),
-                    prefs.getString("uuid", ""),
-                    null);
-        } else {
-            return null;
-        }
-    }
-
-    private String getAWSBucket() {
-        return getStorage().getString("app_name", "");
-    }
-
-    private JsonFactory getJsonFactory() {
-        if (mJsonFactory == null)
-            mJsonFactory = new JacksonFactory();
-        return mJsonFactory;
-    }
-
-    private JsonObjectParser getJsonObjectParser() {
-        if (mJsonObjectParser == null)
-            mJsonObjectParser = new JsonObjectParser(getJsonFactory());
-        return mJsonObjectParser;
-    }
-
-    private void postExceptionToCallback(final KickflipCallback cb, final int resourceCodeId) {
-        final int errorCode = getContext().getResources().getInteger(resourceCodeId);
-        final String message = getContext().getResources().getStringArray(R.array.error_messages)[errorCode];
-        KickflipException error = new KickflipException(message, errorCode);
-        postExceptionToCallback(cb, error);
-    }
-
-    private void postExceptionToCallback(final KickflipCallback cb, final KickflipException exception) {
-        if (cb != null) {
-            mCallbackHandler.post(new Runnable() {
-                @Override
-                public void run() {
-                    cb.onError(exception);
-                }
-            });
-        }
-    }
-
-    private void postResponseToCallback(final KickflipCallback cb, final Response response) {
-        if (cb != null) {
-            mCallbackHandler.post(new Runnable() {
-                @Override
-                public void run() {
-                    cb.onSuccess(response);
-                }
-            });
-        }
-    }
-
-    /**
-     * Given a string like https://api.kickflip.io/api/search
-     * return /api/search
-     *
-     * @param url
-     * @return
-     */
-    private String shortenUrlString(String url) {
-        return url.substring(BASE_URL.length());
-    }
-
-    /**
-     * Check if a Stream is owned by the active Kickflip User.
-     *
-     * @param stream the Stream to test.
-     * @return true if the active Kickflip User owns the Stream. false otherwise.
-     */
-    public boolean activeUserOwnsStream(Stream stream) {
-        return getActiveUser().getName().compareTo(stream.getOwnerName()) == 0;
-    }
-
-    private boolean assertActiveUserAvailable(KickflipCallback cb) {
-        if (getActiveUser() == null) {
-            Log.e(TAG, "getStreamsByKeyword called before user acquired. If this request needs to be performed on app start," +
-                    "call it from the KickflipCallback provided to setup()");
-            if (cb != null) {
-                postExceptionToCallback(cb, R.integer.user_not_available);
-            }
-            return false;
-        }
-        return true;
-    }
-
-    private static enum METHOD {GET, POST}
-
-    static {
-        if (DEV_ENDPOINT)
-            BASE_URL = "http://funkcity.ngrok.com";
-        else
-            BASE_URL = "https://www.kickflip.io";
-    }
-
-    private String generateRandomPassword() {
-        return new BigInteger(130, new SecureRandom()).toString(32);
-    }
-
-    private void addPaginationData(int pageNumber, int itemsPerPage, GenericData target) {
-        target.put("results_per_page", itemsPerPage);
-        target.put("page", pageNumber);
-    }
-
-    private String makeApiUrl(String endpoint) {
-        return BASE_URL + "/api" + API_VERSION + endpoint;
-    }
-
-}
diff --git a/sdk/src/main/java/io/kickflip/sdk/av/Broadcaster.java b/sdk/src/main/java/io/kickflip/sdk/av/Broadcaster.java
index fb8d6af..7031d93 100644
--- a/sdk/src/main/java/io/kickflip/sdk/av/Broadcaster.java
+++ b/sdk/src/main/java/io/kickflip/sdk/av/Broadcaster.java
@@ -2,9 +2,7 @@ package io.kickflip.sdk.av;
 
 import android.content.Context;
 import android.util.Log;
-import android.util.Pair;
 
-import com.amazonaws.auth.BasicAWSCredentials;
 import com.amazonaws.services.s3.model.ObjectMetadata;
 import com.amazonaws.services.s3.model.PutObjectRequest;
 import com.google.common.eventbus.DeadEvent;
@@ -12,16 +10,18 @@ import com.google.common.eventbus.EventBus;
 import com.google.common.eventbus.Subscribe;
 
 import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
 import java.io.IOException;
-import java.util.ArrayDeque;
+import java.net.DatagramPacket;
+import java.net.DatagramSocket;
+import java.net.InetAddress;
+import java.net.Socket;
+import java.util.concurrent.LinkedBlockingQueue;
 
 import io.kickflip.sdk.FileUtils;
 import io.kickflip.sdk.Kickflip;
-import io.kickflip.sdk.api.KickflipApiClient;
-import io.kickflip.sdk.api.KickflipCallback;
 import io.kickflip.sdk.api.json.HlsStream;
-import io.kickflip.sdk.api.json.Response;
-import io.kickflip.sdk.api.json.User;
 import io.kickflip.sdk.api.s3.S3BroadcastManager;
 import io.kickflip.sdk.event.BroadcastIsBufferingEvent;
 import io.kickflip.sdk.event.BroadcastIsLiveEvent;
@@ -31,9 +31,7 @@ import io.kickflip.sdk.event.MuxerFinishedEvent;
 import io.kickflip.sdk.event.S3UploadEvent;
 import io.kickflip.sdk.event.StreamLocationAddedEvent;
 import io.kickflip.sdk.event.ThumbnailWrittenEvent;
-import io.kickflip.sdk.exception.KickflipException;
 
-import static com.google.common.base.Preconditions.checkArgument;
 import static io.kickflip.sdk.Kickflip.isKitKat;
 
 /**
@@ -61,12 +59,9 @@ public class Broadcaster extends AVRecorder {
     private static final int MIN_BITRATE = 3 * 100 * 1000;              // 300 kbps
     private final String VOD_FILENAME = "vod.m3u8";
     private Context mContext;
-    private KickflipApiClient mKickflip;
-    private User mUser;
     private HlsStream mStream;
     private HlsFileObserver mFileObserver;
-    private S3BroadcastManager mS3Manager;
-    private ArrayDeque<Pair<String, File>> mUploadQueue;
+    private LinkedBlockingQueue<File> mUploadQueue;
     private SessionConfig mConfig;
     private BroadcastListener mBroadcastListener;
     private EventBus mEventBus;
@@ -80,18 +75,18 @@ public class Broadcaster extends AVRecorder {
     private boolean mDeleteAfterUploading;                              // Should recording files be deleted as they're uploaded?
     private ObjectMetadata mS3ManifestMeta;
 
+    private DatagramSocket uploadSocket;
+
 
     /**
      * Construct a Broadcaster with Session settings and Kickflip credentials
      *
      * @param context       the host application {@link android.content.Context}.
      * @param config        the Session configuration. Specifies bitrates, resolution etc.
-     * @param CLIENT_ID     the Client ID available from your Kickflip.io dashboard.
-     * @param CLIENT_SECRET the Client Secret available from your Kickflip.io dashboard.
      */
-    public Broadcaster(Context context, SessionConfig config, String CLIENT_ID, String CLIENT_SECRET) {
+    public Broadcaster(Context context, SessionConfig config) {
         super(config);
-        checkArgument(CLIENT_ID != null && CLIENT_SECRET != null);
+        //checkArgument(CLIENT_ID != null && CLIENT_SECRET != null);
         init();
         mContext = context;
         mConfig = config;
@@ -109,21 +104,13 @@ public class Broadcaster extends AVRecorder {
         if (VERBOSE) Log.i(TAG, "Watching " + watchDir);
 
         mReadyToBroadcast = false;
-        mKickflip = Kickflip.setup(context, CLIENT_ID, CLIENT_SECRET, new KickflipCallback() {
-            @Override
-            public void onSuccess(Response response) {
-                User user = (User) response;
-                mUser = user;
-                if (VERBOSE) Log.i(TAG, "Got storage credentials " + response);
-            }
+        Kickflip.setup(context);
 
-            @Override
-            public void onError(KickflipException error) {
-                Log.e(TAG, "Failed to get storage credentials" + error.toString());
-                if (mBroadcastListener != null)
-                    mBroadcastListener.onBroadcastError(error);
-            }
-        });
+        try {
+            uploadSocket = new DatagramSocket();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
     }
 
     private void init() {
@@ -182,20 +169,8 @@ public class Broadcaster extends AVRecorder {
     @Override
     public void startRecording() {
         super.startRecording();
-        mKickflip.startStream(mConfig.getStream(), new KickflipCallback() {
-            @Override
-            public void onSuccess(Response response) {
-                mCamEncoder.requestThumbnailOnDeltaFrameWithScaling(10, 1);
-                Log.i(TAG, "got StartStreamResponse");
-                checkArgument(response instanceof HlsStream, "Got unexpected StartStream Response");
-                onGotStreamResponse((HlsStream) response);
-            }
-
-            @Override
-            public void onError(KickflipException error) {
-                Log.w(TAG, "Error getting start stream response! " + error);
-            }
-        });
+        onGotStreamResponse(new HlsStream());
+        dequeueUploads();
     }
 
     private void onGotStreamResponse(HlsStream stream) {
@@ -208,11 +183,7 @@ public class Broadcaster extends AVRecorder {
         mStream.setExtraInfo(mConfig.getExtraInfo());
         mStream.setIsPrivate(mConfig.isPrivate());
         if (VERBOSE) Log.i(TAG, "Got hls start stream " + stream);
-        mS3Manager = new S3BroadcastManager(this, new BasicAWSCredentials(mStream.getAwsKey(), mStream.getAwsSecret()));
-        mS3Manager.setRegion(mStream.getRegion());
-        mS3Manager.addRequestInterceptor(mS3RequestInterceptor);
         mReadyToBroadcast = true;
-        submitQueuedUploadsToS3();
         mEventBus.post(new BroadcastIsBufferingEvent());
         if (mBroadcastListener != null) {
             mBroadcastListener.onBroadcastStart();
@@ -237,18 +208,7 @@ public class Broadcaster extends AVRecorder {
         super.stopRecording();
         mSentBroadcastLiveEvent = false;
         if (mStream != null) {
-            if (VERBOSE) Log.i(TAG, "Stopping Stream");
-            mKickflip.stopStream(mStream, new KickflipCallback() {
-                @Override
-                public void onSuccess(Response response) {
-                    if (VERBOSE) Log.i(TAG, "Got stop stream response " + response);
-                }
 
-                @Override
-                public void onError(KickflipException error) {
-                    Log.w(TAG, "Error getting stop stream response! " + error);
-                }
-            });
         }
     }
 
@@ -264,7 +224,7 @@ public class Broadcaster extends AVRecorder {
     public void onSegmentWritten(HlsSegmentWrittenEvent event) {
         try {
             File hlsSegment = event.getSegment();
-            queueOrSubmitUpload(keyForFilename(hlsSegment.getName()), hlsSegment);
+            queueOrSubmitUpload(hlsSegment);
             if (isKitKat() && mConfig.isAdaptiveBitrate() && isRecording()) {
                 // Adjust bitrate to match expected filesize
                 long actualSegmentSizeBytes = hlsSegment.length();
@@ -353,7 +313,7 @@ public class Broadcaster extends AVRecorder {
         } catch (IOException e1) {
             e1.printStackTrace();
         }
-        queueOrSubmitUpload(keyForFilename("index.m3u8"), copy);
+        queueOrSubmitUpload(copy);
         appendLastManifestEntryToEventManifest(copy, !isRecording());
         mNumSegmentsWritten++;
     }
@@ -390,7 +350,7 @@ public class Broadcaster extends AVRecorder {
     @Subscribe
     public void onThumbnailWritten(ThumbnailWrittenEvent e) {
         try {
-            queueOrSubmitUpload(keyForFilename("thumb.jpg"), e.getThumbnailFile());
+            queueOrSubmitUpload(e.getThumbnailFile());
         } catch (Exception ex) {
             Log.i(TAG, "Error writing thumbanil");
             ex.printStackTrace();
@@ -431,7 +391,7 @@ public class Broadcaster extends AVRecorder {
 
     private void sendStreamMetaData() {
         if (mStream != null) {
-            mKickflip.setStreamInfo(mStream, null);
+
         }
     }
 
@@ -447,46 +407,53 @@ public class Broadcaster extends AVRecorder {
      * Handle an upload, either submitting to the S3 client
      * or queueing for submission once credentials are ready
      *
-     * @param key  destination key
      * @param file local file
      */
-    private void queueOrSubmitUpload(String key, File file) {
+    private void queueOrSubmitUpload(File file) {
         if (mReadyToBroadcast) {
-            submitUpload(key, file);
+            submitUpload(file);
         } else {
-            if (VERBOSE) Log.i(TAG, "queueing " + key + " until S3 Credentials available");
-            queueUpload(key, file);
+            queueUpload(file);
         }
     }
 
     /**
      * Queue an upload for later submission to S3
      *
-     * @param key  destination key
      * @param file local file
      */
-    private void queueUpload(String key, File file) {
+    private void queueUpload(File file) {
         if (mUploadQueue == null)
-            mUploadQueue = new ArrayDeque<>();
-        mUploadQueue.add(new Pair<>(key, file));
+            mUploadQueue = new LinkedBlockingQueue<File>();
+        mUploadQueue.add(file);
     }
 
-    /**
-     * Submit all queued uploads to the S3 client
-     */
-    private void submitQueuedUploadsToS3() {
-        if (mUploadQueue == null) return;
-        for (Pair<String, File> pair : mUploadQueue) {
-            submitUpload(pair.first, pair.second);
-        }
+    private void submitUpload(final File file) {
+        submitUpload(file, false);
     }
 
-    private void submitUpload(final String key, final File file) {
-        submitUpload(key, file, false);
-    }
+    private void submitUpload(final File file, boolean lastUpload) {
+        //TODO real uploads
+        int read = 0;
+        try {
+            FileInputStream fis = new FileInputStream(file);
+            byte[] buffer = new byte[188];
+            while((read = fis.read(buffer)) > 0) {
+                if(read < 188) {
+                    read += fis.read(buffer, read, 188-read);
+                }
+                if(buffer[0] != 71) {
+                    continue;
+                }
+                DatagramPacket packet = new DatagramPacket(buffer, 0, read, InetAddress.getByName("192.168.1.128"), 8000);
+                uploadSocket.send(packet);
+            }
+        } catch (FileNotFoundException e) {
+            e.printStackTrace();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
 
-    private void submitUpload(final String key, final File file, boolean lastUpload) {
-        mS3Manager.queueUpload(mStream.getAwsS3Bucket(), key, file, lastUpload);
     }
 
     /**
@@ -524,7 +491,7 @@ public class Broadcaster extends AVRecorder {
         String result = FileUtils.tail2(sourceManifest, lastEntry ? 3 : 2);
         FileUtils.writeStringToFile(result, mVodManifest, true);
         if (lastEntry) {
-            submitUpload(keyForFilename("vod.m3u8"), mVodManifest, true);
+            submitUpload(mVodManifest, true);
             if (VERBOSE) Log.i(TAG, "Queued master manifest " + mVodManifest.getAbsolutePath());
         }
     }
@@ -542,4 +509,14 @@ public class Broadcaster extends AVRecorder {
         }
     };
 
+    private void dequeueUploads() {
+        if(mUploadQueue == null) {
+            return;
+        }
+
+        for(File f : mUploadQueue) {
+            submitUpload(f);
+        }
+    }
+
 }
diff --git a/sdk/src/main/java/io/kickflip/sdk/av/FFmpegMuxer.java b/sdk/src/main/java/io/kickflip/sdk/av/FFmpegMuxer.java
index b4a8b2c..0a5e861 100644
--- a/sdk/src/main/java/io/kickflip/sdk/av/FFmpegMuxer.java
+++ b/sdk/src/main/java/io/kickflip/sdk/av/FFmpegMuxer.java
@@ -133,6 +133,10 @@ public class FFmpegMuxer extends Muxer implements Runnable {
         super.addTrack(trackFormat);
         if (!mStarted) {
             Log.i(TAG, "PrepareAVFormatContext for path " + getOutputPath());
+            File directory = new File(getOutputPath()).getParentFile();
+            if(!directory.exists()) {
+                directory.mkdirs();
+            }
             mFFmpeg.prepareAVFormatContext(getOutputPath());
             mStarted = true;
         }
diff --git a/sdk/src/main/java/io/kickflip/sdk/av/M3u8Parser.java b/sdk/src/main/java/io/kickflip/sdk/av/M3u8Parser.java
index 657995a..1769fc2 100644
--- a/sdk/src/main/java/io/kickflip/sdk/av/M3u8Parser.java
+++ b/sdk/src/main/java/io/kickflip/sdk/av/M3u8Parser.java
@@ -11,8 +11,6 @@ import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.net.URL;
 
-import io.kickflip.sdk.api.KickflipApiClient;
-
 import static io.kickflip.sdk.Kickflip.isKickflipUrl;
 
 /**
@@ -27,7 +25,7 @@ public class M3u8Parser {
         public void onError(Exception e);
     }
 
-    public static void getM3u8FromUrl(KickflipApiClient kickflip, String url, final M3u8ParserCallback cb) {
+    public static void getM3u8FromUrl(String url, final M3u8ParserCallback cb) {
         if (isKickflipUrl(Uri.parse(url))) {
 
         } else if(url.substring(url.lastIndexOf(".")+1).equals("m3u8")) {
diff --git a/sdk/src/main/java/io/kickflip/sdk/fragment/BroadcastFragment.java b/sdk/src/main/java/io/kickflip/sdk/fragment/BroadcastFragment.java
index 19a0be2..33d50c7 100644
--- a/sdk/src/main/java/io/kickflip/sdk/fragment/BroadcastFragment.java
+++ b/sdk/src/main/java/io/kickflip/sdk/fragment/BroadcastFragment.java
@@ -159,11 +159,7 @@ public class BroadcastFragment extends Fragment implements AdapterView.OnItemSel
     public void onCreate(Bundle savedInstanceState) {
         if (VERBOSE) Log.i(TAG, "onCreate");
         super.onCreate(savedInstanceState);
-        if (!Kickflip.readyToBroadcast()) {
-            Log.e(TAG, "Kickflip not properly prepared by BroadcastFragment's onCreate. SessionConfig: " + Kickflip.getSessionConfig() + " key " + Kickflip.getApiKey() + " secret " + Kickflip.getApiSecret());
-        } else {
-            setupBroadcaster();
-        }
+        setupBroadcaster();
     }
 
     @Override
@@ -241,10 +237,10 @@ public class BroadcastFragment extends Fragment implements AdapterView.OnItemSel
         if (getActivity().getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
             if (mBroadcaster == null) {
                 if (VERBOSE)
-                    Log.i(TAG, "Setting up Broadcaster for output " + Kickflip.getSessionConfig().getOutputPath() + " client key: " + Kickflip.getApiKey() + " secret: " + Kickflip.getApiSecret());
+                    Log.i(TAG, "Setting up Broadcaster for output " + Kickflip.getSessionConfig().getOutputPath());
                 // TODO: Don't start recording until stream start response, so we can determine stream type...
                 Context context = getActivity().getApplicationContext();
-                mBroadcaster = new Broadcaster(context, Kickflip.getSessionConfig(), Kickflip.getApiKey(), Kickflip.getApiSecret());
+                mBroadcaster = new Broadcaster(context, Kickflip.getSessionConfig());
                 mBroadcaster.getEventBus().register(this);
                 mBroadcaster.setBroadcastListener(Kickflip.getBroadcastListener());
                 Kickflip.clearSessionConfig();
diff --git a/sdk/src/main/java/io/kickflip/sdk/fragment/GlassBroadcastFragment.java b/sdk/src/main/java/io/kickflip/sdk/fragment/GlassBroadcastFragment.java
index 0446932..083734c 100644
--- a/sdk/src/main/java/io/kickflip/sdk/fragment/GlassBroadcastFragment.java
+++ b/sdk/src/main/java/io/kickflip/sdk/fragment/GlassBroadcastFragment.java
@@ -67,7 +67,7 @@ public class GlassBroadcastFragment extends Fragment {
         if (VERBOSE) Log.i(TAG, "onCreate");
         super.onCreate(savedInstanceState);
         if (!Kickflip.readyToBroadcast()) {
-            Log.e(TAG, "Kickflip not properly prepared by BroadcastFragment's onCreate. SessionConfig: " + Kickflip.getSessionConfig() + " key " + Kickflip.getApiKey() + " secret " + Kickflip.getApiSecret());
+            Log.e(TAG, "Kickflip not properly prepared by BroadcastFragment's onCreate. SessionConfig: " + Kickflip.getSessionConfig());
         } else {
             setupBroadcaster();
             mBroadcaster.startRecording();
@@ -151,10 +151,10 @@ public class GlassBroadcastFragment extends Fragment {
         if (getActivity().getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
             if (mBroadcaster == null) {
                 if (VERBOSE)
-                    Log.i(TAG, "Setting up Broadcaster for output " + Kickflip.getSessionConfig().getOutputPath() + " client key: " + Kickflip.getApiKey() + " secret: " + Kickflip.getApiSecret());
+                    Log.i(TAG, "Setting up Broadcaster for output " + Kickflip.getSessionConfig().getOutputPath());
                 // TODO: Don't start recording until stream start response, so we can determine stream type...
                 Context context = getActivity().getApplicationContext();
-                mBroadcaster = new Broadcaster(context, Kickflip.getSessionConfig(), Kickflip.getApiKey(), Kickflip.getApiSecret());
+                mBroadcaster = new Broadcaster(context, Kickflip.getSessionConfig());
                 mBroadcaster.getEventBus().register(this);
                 mBroadcaster.setBroadcastListener(Kickflip.getBroadcastListener());
                 Kickflip.clearSessionConfig();
diff --git a/sdk/src/main/java/io/kickflip/sdk/fragment/MediaPlayerFragment.java b/sdk/src/main/java/io/kickflip/sdk/fragment/MediaPlayerFragment.java
index 2916e9d..c29594c 100644
--- a/sdk/src/main/java/io/kickflip/sdk/fragment/MediaPlayerFragment.java
+++ b/sdk/src/main/java/io/kickflip/sdk/fragment/MediaPlayerFragment.java
@@ -24,7 +24,6 @@ import java.io.IOException;
 
 import io.kickflip.sdk.Kickflip;
 import io.kickflip.sdk.R;
-import io.kickflip.sdk.api.KickflipApiClient;
 import io.kickflip.sdk.api.KickflipCallback;
 import io.kickflip.sdk.api.json.Response;
 import io.kickflip.sdk.api.json.Stream;
@@ -39,7 +38,6 @@ public class MediaPlayerFragment extends Fragment implements TextureView.Surface
     private static final String TAG = "MediaPlayerFragment";
     private static final boolean VERBOSE = false;
     private static final String ARG_URL = "url";
-    private KickflipApiClient mKickflip;
 
     private ProgressBar mProgress;
     private TextureView mTextureView;
@@ -96,24 +94,10 @@ public class MediaPlayerFragment extends Fragment implements TextureView.Surface
         if (getArguments() != null) {
             mMediaUrl = getArguments().getString(ARG_URL);
             // NOTE: the kickflip client may not be fully initialized immediately.
-            mKickflip = Kickflip.getApiClient(getActivity(), null);
             if (Kickflip.isKickflipUrl(Uri.parse(mMediaUrl))) {
                 Log.i(TAG, "MediaPlayerFragment got kickflip url");
                 String streamId = Kickflip.getStreamIdFromKickflipUrl(Uri.parse(mMediaUrl));
-                mKickflip.getStreamInfo(streamId, new KickflipCallback() {
-                    @Override
-                    public void onSuccess(Response response) {
-                        Stream stream = (Stream) response;
-                        Log.i(TAG, "got kickflip stream meta: " + stream.getStreamUrl());
-                        mMediaUrl = stream.getStreamUrl();
-                        parseM3u8FromMediaUrl();
-                    }
 
-                    @Override
-                    public void onError(KickflipException error) {
-                        Log.i(TAG, "get kickflip stream meta failed");
-                    }
-                });
             } else if (mMediaUrl.substring(mMediaUrl.lastIndexOf(".") + 1).equals("m3u8")) {
                 parseM3u8FromMediaUrl();
             } else {
